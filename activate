export CONFIG_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)" # ${BASH_SOURCE}

#PRINT_DIRECTORY_STRUCTURE
alias dev-tools-directory-structure="$CONFIG_ROOT/scripts/cpp/dst/print_directory_structure"
#FIND_NETWORK
alias dev-tools-find-net="$CONFIG_ROOT/scripts/bash/find_network/find_network.sh"

# ============================
#       UNIT CONFIGURATION
# ============================

dev-tools-vscode-configuration() {
	case "$1" in
	cpp)
		$CONFIG_ROOT/scripts/cpp/dst/vscode_config_manager create $CONFIG_ROOT/configs/cpp/.vscode
		;;
	py)
		$CONFIG_ROOT/scripts/cpp/dst/vscode_config_manager create $CONFIG_ROOT/configs/py/.vscode
		;;
	common)
		$CONFIG_ROOT/scripts/cpp/dst/vscode_config_manager create $CONFIG_ROOT/configs/code/common/.vscode
		;;
	*)
		echo -e "Invalid argument: "$1".\nUse: 'cpp' or 'py' or 'common'" >&2
		return 1
		;;
	esac
}

dev-tools-clang-toml-configuration() {
	cp "$CONFIG_ROOT/configs/clang/.clang-format" .
	cp "$CONFIG_ROOT/configs/clang/.clang-tidy" .
	cp "$CONFIG_ROOT/configs/py/pyproject.toml" .
	echo "Clang configs (.clang-format, .clang-tidy) and toml config copied to $(pwd)"
}

dev-tools-py-env-init() {
	python3.9 -m venv .venv
	source ./.venv/bin/activate
	pip install --upgrade pip
	pip install black mypy flake8 isort debugpy flake8-pyproject
	echo "Python VENV ready with Black, Mypy, Flake8 and Isort."
}

# ============================
#       SSH MANAGEMENT
# ============================

s() {
	local target=$1
	local SSH_MAP_REAL="$CONFIG_ROOT/configs/ssh/hosts.map"

	if [ ! -f "$SSH_MAP_REAL" ]; then
		echo "Error: Host map not found. Run 'dev-tools-init-ssh' first."
		return 1
	fi

	unset HOSTS_MAP
	declare -A HOSTS_MAP
	source "$SSH_MAP_REAL"

	if [ -z "$target" ]; then
		echo "Available hosts (from $SSH_MAP_REAL):"
		for key in "${!HOSTS_MAP[@]}"; do
			printf "  %-15s -> %s\n" "$key" "${HOSTS_MAP[$key]}"
		done
		return 0
	fi

	if [[ -v HOSTS_MAP[$target] ]]; then
		ssh "${HOSTS_MAP[$target]}"
	else
		echo "Error: Host '$target' not found in $SSH_MAP_REAL"
		return 1
	fi
}

dev-tools-init-ssh() {
	local SSH_DIR="$CONFIG_ROOT/configs/ssh"
	mkdir -p "$SSH_DIR"
	if [ ! -f "$SSH_DIR/hosts.map" ]; then
		echo 'HOSTS_MAP+=( ["test"]="ace@127.0.0.1" )' >"$SSH_DIR/hosts.map"
		echo "SSH map created: $SSH_DIR/hosts.map"
	fi
}

# ============================
#       SYSTEM & CONFIG
# ============================

dev-tools-install-sys() {
	echo "Updating system packages and installing dependencies..."

	local PACKAGES=(
		build-essential
		cmake
		git
		gdb
		lldb
		clang
		clangd
		clang-format
		clang-tidy
		cppcheck
		pkg-config
		make
		bash-completion
		curl
		wget
		openssh-client
		#shfmt
		valgrind
		# python3 python3-pip python3-venv
		# libprotobuf-dev libgrpc++-dev libgrpc-dev libprotoc-dev
	)

	sudo apt update && sudo apt install -y "${PACKAGES[@]}"

	if [ $? -eq 0 ]; then
		echo "All system dependencies installed successfully!"
	else
		echo "Error: Package installation failed."
		return 1
	fi
}

dev-tools-vscode-sync-extension() {
	local EXT_DIR="$HOME/.vscode/extensions"
	local ARCHIVE="$CONFIG_ROOT/configs/code/code.tar.xz"

	mkdir -p "$EXT_DIR"

	echo "Unpacking extensions to $EXT_DIR..."
	tar -xJf "$ARCHIVE" -C "$EXT_DIR" \
		--strip-components=2 \
		--exclude='*.json' \
		--exclude='*.vsix' \
		--exclude='*.deb'

	echo "Done! Restart VS Code to apply changes."
}

dev-tools-build-cpp() {
	local BUILD_SCRIPT="$CONFIG_ROOT/install/build/build.sh"
	if [ -f "$BUILD_SCRIPT" ]; then
		bash "$BUILD_SCRIPT"
	else
		echo "Error: Build script not found at $BUILD_SCRIPT"
	fi
}

dev-tools-vim-configuration() {
	if [ -f "$CONFIG_ROOT/configs/vim/.vimrc" ]; then
		if ! cmp -s "$CONFIG_ROOT/configs/vim/.vimrc" "$HOME/.vimrc"; then
			cp "$CONFIG_ROOT/configs/vim/.vimrc" "$HOME/.vimrc"
			echo "Vim config updated in $HOME"
		fi
	else
		echo "Error: .vimrc not found in $CONFIG_ROOT/configs/vim/"
	fi
}

# ============================
#       BUILD SYSTEM & CONFIG
# ============================

dev-tools-default-init-conf() {
	dev-tools-vscode-configuration common
	dev-tools-clang-toml-configuration
}

dev-tools-default_init-system() {
	dev-tools-install-sys
	dev-tools-vscode-sync-extension
	dev-tools-build-cpp
	dev-tools-vim-configuration
	dev-tools-init-ssh
}

# ============================
#       CPP TOOLS
# ============================

dev-tools-tidy() {
	local LOCAL_CONFIG="$CONFIG_ROOT/configs/clang/.clang-tidy"

	local DB_PATH=""
	[ -d "./build" ] && [ -f "./build/compile_commands.json" ] && DB_PATH="build"
	[ -d "./build-debug" ] && [ -f "./build-debug/compile_commands.json" ] && DB_PATH="build-debug"

	local FILES=""
	if [ -z "$1" ]; then
		FILES=$(find . -maxdepth 1 -name "*.cpp" -o -name "*.hpp" -o -name "*.c" -o -name "*.h")
	else
		if [ -d "$1" ]; then
			# Если это директория — ищем файлы внутри неё
			FILES=$(find "$1" -maxdepth 1 -name "*.cpp" -o -name "*.hpp" -o -name "*.c" -o -name "*.h")
		else
			# Если это не директория, считаем, что это список файлов (или маска типа *.cpp)
			FILES="$@"
		fi
	fi

	if [ -z "$FILES" ]; then
		echo "No source files found to check."
		return 0
	fi

	local TEAM_CONFIG
	TEAM_CONFIG=$(git rev-parse --show-toplevel 2>/dev/null | xargs -I {} find {} -maxdepth 2 -name ".clang-tidy" | head -n 1)

	if [ -n "$TEAM_CONFIG" ]; then
		echo "--> Using TEAM config: $TEAM_CONFIG"
		if [ -n "$DB_PATH" ]; then
			clang-tidy $FILES -p "$DB_PATH"
		else
			clang-tidy $FILES -- -std=c++17
		fi
	else
		echo "--> Using LOCAL config."
		if [ -n "$DB_PATH" ]; then
			clang-tidy $FILES -p "$DB_PATH" --config="$(cat "$LOCAL_CONFIG")"
		else
			clang-tidy $FILES --config="$(cat "$LOCAL_CONFIG")" -- -std=c++17
		fi
	fi
}

dev-tools-fmt() {
	local LOCAL_FORMAT="$CONFIG_ROOT/configs/clang/.clang-format"

	local FILES=""
	if [ -z "$1" ]; then
		FILES=$(find . -maxdepth 1 -name "*.cpp" -o -name "*.hpp" -o -name "*.c" -o -name "*.h")
	else
		FILES="$@"
	fi

	if [ -z "$FILES" ]; then
		echo "No source files found to format."
		return 0
	fi

	local TEAM_FORMAT
	TEAM_FORMAT=$(git rev-parse --show-toplevel 2>/dev/null | xargs -I {} find {} -maxdepth 2 -name ".clang-format" | head -n 1)

	if [ -n "$TEAM_FORMAT" ]; then
		echo "--> Formatting with TEAM config: $TEAM_FORMAT"
		clang-format -i $FILES
	else
		echo "--> Formatting with LOCAL config."
		clang-format -i -style="file:$LOCAL_FORMAT" $FILES
	fi
}

dev-tools-cpp-check() {
	local TARGET=${1:-"."}
	echo "Running cppcheck on $TARGET..."
	# --enable=all включает все проверки (style, performance, portability)
	# --suppress=missingIncludeSystem убирает шум от системных либ
	# -i пропускать
	local COMMON_FLAGS="--enable=all --suppress=missingIncludeSystem --suppress=unusedFunction -i build -i build-debug"

	# Если мы запускаем просто `cpp-check` без аргументов и есть база — проверяем ВЕСЬ проект
	if [ -z "$1" ] && [ -f "./build-debug/compile_commands.json" ]; then
		echo "--> Using project file (full scan)"
		cppcheck --project=build-debug/compile_commands.json $COMMON_FLAGS
	elif [ -z "$1" ] && [ -f "./build/compile_commands.json" ]; then
		echo "--> Using project file (full scan)"
		cppcheck --project=build/compile_commands.json $COMMON_FLAGS
	else
		echo "--> Manual scan mode"
		local ALL_HEADER_DIRS=$(find . -type f \( -name "*.h" -o -name "*.hpp" \) -exec dirname {} + | sort -u | xargs -I {} echo -n "-I {} ")

		cppcheck $COMMON_FLAGS --inconclusive --std=c++17 \
			$ALL_HEADER_DIRS "$TARGET"
	fi
}

# ============================
#       SANDBOX & VALGRIND
# ============================

# Генератор шаблона теста
dev-tools-sandbox-create() {
	[ -z "$1" ] && {
		echo "Usage: sandbox-create <ClassName>"
		return 1
	}
	local CLASS_NAME="$1"
	local FILE="test_${CLASS_NAME}.cpp"

	if [ -f "$FILE" ]; then
		echo "Error: $FILE already exists!"
		return 1
	fi

	cat >"$FILE" <<EOF
#include <iostream>
#include <cassert>
#include <stdexcept>
#include "${CLASS_NAME}.hpp"

// ============ Basic tests ============
void test_logic() {
    std::cout << "Running test_logic... ";
    // ${CLASS_NAME} obj;
    // assert(obj.some_method() == true);
    std::cout << "OK" << std::endl;
}

// ============ Memory tests ============
void test_memory() {
    std::cout << "Running test_memory... ";
    ${CLASS_NAME}* obj = new ${CLASS_NAME}();
    // TODO: test something
    delete obj;
    std::cout << "OK" << std::endl;
}

int main() {
    std::cout << "=== RUNNING TESTS FOR ${CLASS_NAME} ===\n" << std::endl;
    try {
        test_logic();
        test_memory();
        std::cout << "\nALL TESTS PASSED!" << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "\nTEST FAILED: " << e.what() << std::endl;
        return 1;
    } catch (...) {
        std::cerr << "\nUNKNOWN ERROR" << std::endl;
        return 1;
    }
    return 0;
}
EOF
	echo "Template created: $FILE"
	code "$FILE"
}

dev-tools-sandbox-build() {
	[ -z "$1" ] && {
		echo "Usage: sandbox-build <test.cpp>"
		return 1
	}

	local TEST_FILE=$1
	local OUTPUT="sandbox_bin"

	# Собираем инклуды
	local ALL_INC=$(find . -type f \( -name "*.h" -o -name "*.hpp" \) -exec dirname {} + | sort -u | xargs -I {} echo -n "-I{} ")

	# Ищем объектные файлы, ИСКЛЮЧАЯ все, где в имени есть "main"
	local BUILD_DIR="./build-debug"
	local OBJS=""
	if [ -d "$BUILD_DIR" ]; then
		echo "--> Linking with objects from $BUILD_DIR (excluding all mains)"
		# Мы исключаем любые файлы, в пути которых есть "main.cpp.o" или "main.o"
		OBJS=$(find "$BUILD_DIR" -name "*.o" | grep -vE "/main\.(cpp|c)?\.o$")
	fi

	echo "Building sandbox..."
	# Добавляем -v в случае ошибок, чтобы видеть, что именно линкуется
	g++ -std=c++17 -g -O0 $ALL_INC "$TEST_FILE" $OBJS -o "$OUTPUT"

	if [ $? -eq 0 ]; then
		echo "Success! Run: mem-check ./$OUTPUT"
	else
		echo "Build failed. Check for duplicate symbols or missing objects."
	fi
}

dev-tools-mem-check() {
	if [ -z "$1" ]; then
		echo "Usage: mem-check <path_to_binary> [args]"
		return 1
	fi

	local BINARY=$1
	shift # Убираем имя бинарника из аргументов
	#--log-file=valgrind.log
	echo "Running Valgrind for $BINARY..."
	# --leak-check=full ищет каждую утечку
	# --track-origins=yes показывает, где была выделена память
	valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes "$BINARY" "$@"
}

dev-tools-sandbox-valgrind() {
	[ -z "$1" ] && {
		echo "Usage: sandbox-test <test.cpp>"
		return 1
	}

	local TEST_FILE=$1
	local OUTPUT="sandbox_bin_temp"

	if sandbox-build "$TEST_FILE"; then
		[ -f "sandbox_bin" ] && mv "sandbox_bin" "$OUTPUT"

		echo -e "\n--- START DYNAMIC ANALYSIS ---\n"

		mem-check "./$OUTPUT"

		echo -e "\n--- CLEANING UP ---"
		rm -f "$OUTPUT"
		echo "Temporary binary $OUTPUT removed."
	else
		echo "Error: Build failed, skipping test."
		return 1
	fi
}

dev-tools-sandbox-asan() {
	[ -z "$1" ] && {
		echo "Usage: sandbox-asan <test.cpp>"
		return 1
	}

	local TEST_FILE=$1
	local OUTPUT="sandbox_asan_bin"

	local ALL_INC=$(find . -type f \( -name "*.h" -o -name "*.hpp" \) -exec dirname {} + | sort -u | xargs -I {} echo -n "-I{} ")
	local OBJS=$(find "./build-debug" -name "*.o" | grep -vE "/main\.(cpp|c)?\.o$")

	echo "Building with Address & Undefined Sanitizers..."

	# Ключевые флаги:
	# -fsanitize=address (утечки и память)
	# -fsanitize=undefined (деление на ноль, nullptr и т.д.)
	# -fno-omit-frame-pointer (для красивых стектрейсов)
	g++ -std=c++17 -g -O1 $ALL_INC "$TEST_FILE" $OBJS -o "$OUTPUT" \
		-fsanitize=address -fsanitize=undefined -fno-omit-frame-pointer

	if [ $? -eq 0 ]; then
		echo -e "\n--- RUNNING WITH ASAN ---\n"
		./"$OUTPUT"
		rm -f "$OUTPUT"
	else
		echo "Build failed."
	fi
}

# ============================
#       PY TOOLS
# ============================

dev-tools-py-fix() {
	local TARGET=${1:-"."}
	local LOCAL_CONFIG="$CONFIG_ROOT/configs/py/pyproject.toml"

	if [ -d ".venv" ]; then
		local TEAM_CONFIG
		TEAM_CONFIG=$(git rev-parse --show-toplevel 2>/dev/null | xargs -I {} find {} -maxdepth 2 -name "pyproject.toml" | head -n 1)

		if [ -n "$TEAM_CONFIG" ]; then
			echo "--> Formatting with TEAM config: $TEAM_CONFIG"
			./.venv/bin/black "$TARGET"
			./.venv/bin/isort "$TARGET"
		else
			echo "--> Formatting with LOCAL config."
			./.venv/bin/black --config "$LOCAL_CONFIG" "$TARGET"
			./.venv/bin/isort --settings-path "$LOCAL_CONFIG" "$TARGET"
		fi
	else
		echo "Error: .venv not found."
	fi
}

dev-tools-py-check() {
	local TARGET=${1:-"."}
	local LOCAL_CONFIG="$CONFIG_ROOT/configs/py/pyproject.toml"

	if [ -d ".venv" ]; then
		local TEAM_CONFIG
		TEAM_CONFIG=$(git rev-parse --show-toplevel 2>/dev/null | xargs -I {} find {} -maxdepth 2 -name "pyproject.toml" | head -n 1)

		echo "Checking $TARGET..."
		if [ -n "$TEAM_CONFIG" ]; then
			echo "--> Using TEAM config: $TEAM_CONFIG"
			./.venv/bin/flake8 "$TARGET" --extend-exclude=.venv
			./.venv/bin/mypy "$TARGET" --exclude ".venv"
		else
			echo "--> Using LOCAL config."
			./.venv/bin/flake8 "$TARGET" --extend-exclude=.venv
			./.venv/bin/mypy --config-file "$LOCAL_CONFIG" "$TARGET" --exclude ".venv"
		fi
	else
		echo "Error: .venv not found."
	fi
}

# ============================
#       CMAKE BUILD HELPERS
# ============================

dev-tools-cmake-conf() {
    local TYPE=${1:-debug}
    local DIR="build-${TYPE}"
    local ENV_CONFIG="$CONFIG_ROOT/configs/cmake/build_env"
    
    [ -f "$ENV_CONFIG" ] && source "$ENV_CONFIG"

    local CMD_ARGS="$COMMON_ARGS"
    if [ "$TYPE" == "release" ]; then
        CMD_ARGS="$CMD_ARGS $RELEASE_ARGS"
    else
        CMD_ARGS="$CMD_ARGS $DEBUG_ARGS"
    fi

    [[ ! $CMD_ARGS =~ "CMAKE_BUILD_TYPE" ]] && CMD_ARGS="$CMD_ARGS -DCMAKE_BUILD_TYPE=${TYPE^}"
    [[ ! $CMD_ARGS =~ "CMAKE_EXPORT_COMPILE_COMMANDS" ]] && CMD_ARGS="$CMD_ARGS -DCMAKE_EXPORT_COMPILE_COMMANDS=ON"

    echo "--> Configuring $TYPE in $DIR..."
    echo "--> Full args: $CMD_ARGS"
    cmake -B "$DIR" $CMD_ARGS
}

dev-tools-cmake-build() {
    local TYPE=${1:-debug}
    local DIR="build-${TYPE}"

    if [ ! -d "$DIR" ]; then
        echo "--> Directory $DIR not found. Running config..."
	   echo "$TYPE"
        dev-tools-cmake-conf "$TYPE" || return 1
    fi

    echo "--> Compiling $TYPE..."
    cmake --build "$DIR" -j$(nproc)
}

dev-tools-cmake-rebuild() {
    dev-tools-cmake-clean
    dev-tools-cmake-build "$@"
}

dev-tools-gtest-run() {
	local TYPE=${1:-debug}
	local DIR="build-${TYPE}"

	if [ ! -d "$DIR" ]; then
		echo "Error: Directory $DIR not found. Build it first with 'dev-tools-cmake-build $TYPE'"
		return 1
	fi

	echo "--> Running tests from $DIR..."
	cd "$DIR" && ctest --output-on-failure
	cd - >/dev/null
}

dev-tools-cmake-clean() {
	echo "--> Cleaning all build directories..."
	rm -rf build-debug build-release
}

# ============================
#       INFO
# ============================

dev-tools-info() {
	local W=50
	printf "\nAvailable commands:\n\n"

	# ==== NAVIGATION & SSH ====
	printf "  %-*s - %s\n" "$W" "dev-tools-directory-structure" "prints the directory tree structure of the current project."
	printf "  %-*s - %s\n" "$W" "s <alias>" "SSH connection via hosts.map"

	printf "  %-*s - %s\n" "$W" "dev-tools-find-net <IP> <MASK>" "Example: find-net 192.168.1.10 255.255.255.0"

	# ==== TOOLS (CPP & PY) ====
	echo ""
	printf "  %-*s - %s\n" "$W" "dev-tools-tidy <file> or <>" "Clang-tidy (Team/Repo priority)"
	printf "  %-*s - %s\n" "$W" "dev-tools-fmt <file> or <>" "Clang-format (Team/Repo priority)"
	printf "  %-*s - %s\n" "$W" "dev-tools-py-fix <file/dir>" "Format Python code (Black + Isort)"
	printf "  %-*s - %s\n" "$W" "dev-tools-py-check <file/dir>" "Lint Python code (Flake8 + Mypy)"

	# ==== ANALYZERS (DYNAMICS) ===
	echo ""
	printf "  %-*s - %s\n" "$W" "dev-tools-cpp-check <file/dir>" "Static analysis cppcheck (leaks, nullptrs, unused)"
	printf "  %-*s - %s\n" "$W" "dev-tools-mem-check <bin>" "Run Valgrind"

	# ==== SANDBOX (UNIT TESTING) ====
	echo ""
	printf "  %-*s - %s\n" "$W" "dev-tools-sandbox-create <Class>" "Generate test template (test_Class.cpp)"
	printf "  %-*s - %s\n" "$W" "dev-tools-sandbox-build <test.cpp>" "Build sandbox with project objects (.o)"
	printf "  %-*s - %s\n" "$W" "dev-tools-sandbox-valgrind <test.cpp>" "Deep check (Valgrind) + Auto-clean"
	printf "  %-*s - %s\n" "$W" "dev-tools-sandbox-asan <test.cpp>" "Fast check (Sanitizers) + Auto-clean"

	# CONFIGURATION
	echo ""
	printf "  %-*s - %s\n" "$W" "dev-tools-default-init-conf" "Copy .vsconf, clang-tidy, clang-format"
	printf "  %-*s - %s\n" "$W" "dev-tools-vscode-configuration <lang>" "VSCode Configuration Manager."
	printf "  %-*s - %s\n" "$W" "dev-tools-clang-toml-configuration" "clang configuration copy"
	printf "  %-*s - %s\n" "$W" "dev-tools-py-env-init" "Python VENV"

	# ==== SYSTEM & INIT ====
	echo ""
	printf "  %-*s - %s\n" "$W" "dev-tools-default_init-system" "Build default"
	printf "  %-*s - %s\n" "$W" "dev-tools-install-sys" "Updating system packages and installing dependencies"
	printf "  %-*s - %s\n" "$W" "dev-tools-vscode-sync-extension" "unpacking extensions VScode"
	printf "  %-*s - %s\n" "$W" "dev-tools-build-cpp" "run script-build for cpp"
	printf "  %-*s - %s\n" "$W" "dev-tools-vim-configuration" "update configuration vim in $HOME"
	printf "  %-*s - %s\n" "$W" "dev-tools-init-ssh" "Init config for SSH"

	# ==== BUILD SYSTEM (CMAKE) ====
	echo ""
	printf "  %-*s - %s\n" "$W" "dev-tools-cmake-conf <debug|release>" "Configure CMake with build_env settings"
	printf "  %-*s - %s\n" "$W" "dev-tools-cmake-build <debug|release>" "Compile project (auto-conf if dir missing)"
	printf "  %-*s - %s\n" "$W" "dev-tools-cmake-rebuild <debug|release>" "Clean build directories and compile again"
	printf "  %-*s - %s\n" "$W" "dev-tools-gtest-run <debug|release>" "Run GTest suite via ctest"
	printf "  %-*s - %s\n" "$W" "dev-tools-cmake-clean" "Remove build-debug and build-release"
}
